import streamlit as st
import subprocess
import shutil
import re
from pathlib import Path
import pandas as pd
import numpy as np
import sys

# ==================================================
# Streamlit setup
# ==================================================
st.set_page_config(layout="wide")
st.title("Steel Sector Optimization")
st.caption("AMPL Optimization")

# ==================================================
# Paths
# ==================================================
BASE_DIR = Path(__file__).parent
MAIN_MOD_FILE = BASE_DIR / "main.mod"
PARAM_FILE = BASE_DIR / "parameters.mod"
USER_PARAM_FILE = BASE_DIR / "user_parameters.mod"
RUN_FILE = BASE_DIR / "run_ampl.run"
AMPL_OUTPUT_FILE = BASE_DIR / "ampl_output.txt"
CUSTOM_MAIN_FILE = BASE_DIR / "custom_main.mod"

# ==================================================
# Sanity checks
# ==================================================
if not PARAM_FILE.exists():
    st.error(f"Missing parameters.mod at {PARAM_FILE}")
    st.stop()
    
if not MAIN_MOD_FILE.exists():
    st.error(f"Missing main.mod at {MAIN_MOD_FILE}")
    st.stop()

AMPL_EXE = shutil.which("ampl")
if not AMPL_EXE:
    st.error("AMPL executable not found in PATH")
    st.stop()

# ==================================================
# Load DEFAULT scalar parameters
# ==================================================
param_pattern = re.compile(
    r"^\s*param\s+(\w+)\s+default\s+([0-9.eE+-]+)\s*;",
    re.IGNORECASE
)

# Also capture param declarations without default values
param_simple_pattern = re.compile(
    r"^\s*param\s+(\w+)\s*;",
    re.IGNORECASE
)

def load_params_from_mod():
    """Extract all parameter names from parameters.mod"""
    params = {}
    with open(PARAM_FILE) as f:
        content = f.read()
        
        # Find all param declarations with default values
        for m in param_pattern.finditer(content):
            params[m.group(1)] = float(m.group(2))
            
        # Also find param declarations without defaults
        for m in param_simple_pattern.finditer(content):
            param_name = m.group(1)
            if param_name not in params:
                # Mark as needing user input but no default
                params[param_name] = 0.0
                
    return params

params = load_params_from_mod()

# Display number of parameters found
st.sidebar.metric("Parameters found", len(params))

# ==================================================
# Sidebar parameters
# ==================================================
st.sidebar.header("Model Parameters")
st.sidebar.info("Adjust parameters and click 'Run Optimization'")

user_params = {}
with st.sidebar.expander("Parameters", expanded=True):
    for k in sorted(params.keys()):
        # Create a unique key for each widget
        widget_key = f"param_{k}"
        user_params[k] = st.number_input(
            f"{k}",
            value=float(params[k]),
            format="%.6f",
            key=widget_key
        )

# ==================================================
# Create a custom main.mod that includes user parameters
# BEFORE including other modules
# ==================================================
def create_custom_main():
    """Create a modified main.mod that includes user_parameters.mod 
    right after parameters.mod"""
    
    with open(MAIN_MOD_FILE, 'r') as f:
        main_content = f.read()
    
    # Read the original main.mod content
    with open(MAIN_MOD_FILE, 'r') as f:
        lines = f.readlines()
    
    # Find where to insert user_parameters.mod
    # We want it right after parameters.mod include
    new_lines = []
    for line in lines:
        new_lines.append(line)
        # If this line includes parameters.mod, add user_parameters.mod next
        if 'include parameters.mod;' in line:
            new_lines.append('include user_parameters.mod;\n')
    
    # Write the modified content
    with open(CUSTOM_MAIN_FILE, 'w') as f:
        f.writelines(new_lines)
    
    return CUSTOM_MAIN_FILE

# ==================================================
# Write override file with let statements
# ==================================================
def write_user_parameters(p):
    """Write user parameters as let statements"""
    with open(USER_PARAM_FILE, "w") as f:
        f.write("# User parameter overrides (generated by Streamlit)\n")
        f.write("# These override the defaults in parameters.mod\n\n")
        for k, v in p.items():
            f.write(f"let {k} := {v};\n")
        f.write("\n# End of user parameters\n")

# ==================================================
# Write AMPL run file
# ==================================================
def write_run_file(use_custom_main=True):
    """Create AMPL run script"""
    main_file_to_use = CUSTOM_MAIN_FILE if use_custom_main else MAIN_MOD_FILE
    
    with open(RUN_FILE, "w") as f:
        f.write(f"""# AMPL run script generated by Streamlit
reset;
option log_file "{AMPL_OUTPUT_FILE.name}";
option log_flush 1;
option show_stats 1;

# Display a message
print "Starting optimization with user parameters...";

# Include the main model file (which includes user_parameters.mod)
include "{main_file_to_use.name}";

# Display final status
print "Optimization completed successfully!";
""")

# ==================================================
# Parse AMPL output
# ==================================================
def parse_ampl_output(text):
    """Parse AMPL output and extract results"""
    lines = text.splitlines()
    
    # ==================================================
    # COST PER TON
    # ==================================================
    cost_rows = []
    year = None
    bf = coal = ng = h2 = scrap = avg = np.nan
    capture_cost = np.nan
    
    for i, l in enumerate(lines):
        # Look for year headers
        if "Year" in l and "----" in l:
            year_match = re.search(r'\b(202[5-9]|20[3-5][0-9])\b', l)
            if year_match:
                year = int(year_match.group())
                bf = coal = ng = h2 = scrap = avg = capture_cost = np.nan
        
        # Cost extraction patterns
        if "BF-BOF steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                bf = float(matches[0])
        elif "Coal DRI‚ÄìEAF steel:" in l or "Coal DRI-EAF steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                coal = float(matches[0])
        elif "NG DRI‚ÄìEAF steel:" in l or "NG DRI-EAF steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                ng = float(matches[0])
        elif "H2 DRI‚ÄìEAF steel:" in l or "H2 DRI-EAF steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                h2 = float(matches[0])
        elif "Scrap‚ÄìEAF steel:" in l or "Scrap-EAF steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                scrap = float(matches[0])
        elif "Average Cost:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                avg = float(matches[0])
                cost_rows.append({
                    "Year": year,
                    "BF-BOF ($/t)": bf,
                    "Coal DRI-EAF ($/t)": coal,
                    "NG DRI-EAF ($/t)": ng,
                    "H‚ÇÇ DRI-EAF ($/t)": h2,
                    "Scrap-EAF ($/t)": scrap,
                    "Average ($/t)": avg,
                    "Capture Cost ($/t)": capture_cost
                })
        elif "Capture cost per ton steel:" in l:
            matches = re.findall(r'\$?\s*([\d.]+)', l)
            if matches:
                capture_cost = float(matches[0])
    
    # ==================================================
    # EMISSIONS PER TON
    # ==================================================
    emis_rows = []
    year = None
    bf = coal = ng = h2 = scrap = avg = np.nan
    
    for i, l in enumerate(lines):
        if "Year" in l and "----" in l:
            year_match = re.search(r'\b(202[5-9]|20[3-5][0-9])\b', l)
            if year_match:
                year = int(year_match.group())
                bf = coal = ng = h2 = scrap = avg = np.nan
        
        # Emissions extraction
        if "BF-BOF Total per ton:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                bf = float(matches[0])
        elif "Coal DRI-EAF Total per ton:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                coal = float(matches[0])
        elif "NG DRI-EAF Total per ton:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                ng = float(matches[0])
        elif "H2 DRI-EAF Total per ton:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                h2 = float(matches[0])
        elif "Scrap-EAF Total per ton:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                scrap = float(matches[0])
        elif "Average System Emissions:" in l:
            matches = re.findall(r'([\d.]+)', l)
            if matches:
                avg = float(matches[0])
                emis_rows.append({
                    "Year": year,
                    "BF-BOF (tCO‚ÇÇ/t)": bf,
                    "Coal DRI-EAF (tCO‚ÇÇ/t)": coal,
                    "NG DRI-EAF (tCO‚ÇÇ/t)": ng,
                    "H‚ÇÇ DRI-EAF (tCO‚ÇÇ/t)": h2,
                    "Scrap-EAF (tCO‚ÇÇ/t)": scrap,
                    "Average (tCO‚ÇÇ/t)": avg
                })
    
    return cost_rows, emis_rows

# ==================================================
# Main execution
# ==================================================
if st.button("üöÄ Run Optimization", type="primary"):
    # Create a progress container
    progress_container = st.container()
    
    with progress_container:
        st.write("### Optimization Progress")
        status_text = st.empty()
        progress_bar = st.progress(0)
        
        status_text.text("Preparing parameters...")
        progress_bar.progress(10)
        
        # Step 1: Write user parameters
        write_user_parameters(user_params)
        status_text.text("Parameters written...")
        progress_bar.progress(30)
        
        # Step 2: Create custom main.mod
        create_custom_main()
        status_text.text("Model configured...")
        progress_bar.progress(50)
        
        # Step 3: Write run file
        write_run_file(use_custom_main=True)
        status_text.text("Running AMPL optimization...")
        progress_bar.progress(70)
        
        # Step 4: Run AMPL
        try:
            result = subprocess.run(
                [AMPL_EXE, RUN_FILE.name],
                cwd=BASE_DIR,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            progress_bar.progress(90)
            
            # Check if AMPL ran successfully
            if result.returncode != 0:
                st.error(f"AMPL returned error code: {result.returncode}")
                st.code(result.stderr, language="text")
                st.stop()
            
            # Read the output file
            if AMPL_OUTPUT_FILE.exists():
                text = AMPL_OUTPUT_FILE.read_text(encoding="utf-8", errors="ignore")
                
                # Also capture stdout
                full_output = result.stdout + "\n" + text
                
                # Display raw output in expander
                with st.expander("View AMPL Output"):
                    st.code(full_output, language="text")
                
                # Parse results
                status_text.text("Parsing results...")
                cost_rows, emis_rows = parse_ampl_output(full_output)
                
                progress_bar.progress(100)
                status_text.text("Complete!")
                
                # Display results
                if cost_rows:
                    df_cost = pd.DataFrame(cost_rows)
                    st.subheader("üìä Cost per ton of steel (2025‚Äì2050)")
                    st.dataframe(
                        df_cost.style.format("{:.2f}").background_gradient(cmap="Blues", subset=pd.IndexSlice[:, df_cost.columns[1:]]),
                        use_container_width=True
                    )
                    
                    # Create a chart
                    st.line_chart(
                        df_cost.set_index('Year')[['BF-BOF ($/t)', 'Coal DRI-EAF ($/t)', 
                                                  'NG DRI-EAF ($/t)', 'H‚ÇÇ DRI-EAF ($/t)',
                                                  'Scrap-EAF ($/t)', 'Average ($/t)']]
                    )
                else:
                    st.warning("No cost data found in output.")
                
                if emis_rows:
                    df_emis = pd.DataFrame(emis_rows)
                    st.subheader("üåç CO‚ÇÇ emissions per ton of steel (2025‚Äì2050)")
                    st.dataframe(
                        df_emis.style.format("{:.3f}").background_gradient(cmap="Reds", subset=pd.IndexSlice[:, df_emis.columns[1:]]),
                        use_container_width=True
                    )
                    
                    # Create a chart
                    st.line_chart(
                        df_emis.set_index('Year')[['BF-BOF (tCO‚ÇÇ/t)', 'Coal DRI-EAF (tCO‚ÇÇ/t)', 
                                                  'NG DRI-EAF (tCO‚ÇÇ/t)', 'H‚ÇÇ DRI-EAF (tCO‚ÇÇ/t)',
                                                  'Scrap-EAF (tCO‚ÇÇ/t)', 'Average (tCO‚ÇÇ/t)']]
                    )
                else:
                    st.warning("No emissions data found in output.")
                
                # Display summary statistics
                col1, col2, col3 = st.columns(3)
                if cost_rows:
                    with col1:
                        avg_cost_2025 = df_cost[df_cost['Year'] == 2025]['Average ($/t)'].values[0] if 2025 in df_cost['Year'].values else np.nan
                        st.metric("Avg Cost 2025", f"${avg_cost_2025:.2f}" if not pd.isna(avg_cost_2025) else "N/A")
                    with col2:
                        avg_cost_2050 = df_cost[df_cost['Year'] == 2050]['Average ($/t)'].values[0] if 2050 in df_cost['Year'].values else np.nan
                        st.metric("Avg Cost 2050", f"${avg_cost_2050:.2f}" if not pd.isna(avg_cost_2050) else "N/A")
                if emis_rows:
                    with col3:
                        avg_emis_2050 = df_emis[df_emis['Year'] == 2050]['Average (tCO‚ÇÇ/t)'].values[0] if 2050 in df_emis['Year'].values else np.nan
                        st.metric("Avg Emissions 2050", f"{avg_emis_2050:.3f} tCO‚ÇÇ/t" if not pd.isna(avg_emis_2050) else "N/A")
            else:
                st.error("AMPL did not produce output file.")
                st.code(result.stdout, language="text")
                
        except subprocess.TimeoutExpired:
            st.error("Optimization timed out after 5 minutes.")
        except Exception as e:
            st.error(f"Error running AMPL: {e}")
            import traceback
            st.code(traceback.format_exc(), language="text")

# ==================================================
# Sidebar information
# ==================================================
st.sidebar.divider()
st.sidebar.info("""
### Instructions:
1. Adjust parameters in the sidebar
2. Click 'Run Optimization'
3. View results in the main panel

### Files used:
- `main.mod`: Main AMPL model
- `parameters.mod`: Default parameters
- `user_parameters.mod`: User overrides
""")

# Clean up temporary files on app start
for temp_file in [USER_PARAM_FILE, RUN_FILE, CUSTOM_MAIN_FILE, AMPL_OUTPUT_FILE]:
    if temp_file.exists():
        try:
            temp_file.unlink()
        except:
            pass
